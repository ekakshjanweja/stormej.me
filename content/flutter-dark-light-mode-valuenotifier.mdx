---
title: "The Cleanest Way to Do Dark/Light Mode in Flutter"
date: "2025-11-22"
description: "A simple and effective approach to implement dark and light themes in your Flutter app using ValueNotifier."
---

Hey, I'm Ekaksh.

In this post I'm going to walk you through how I set up dark mode and light mode in Flutter
using nothing besides ValueNotifier and ValueListenableBuilder.

This is exactly the same setup I showed in my YouTube video.

<Yt videoId={"uX_zaJGLIvQ"} />

I use this pattern in basically every Flutter app I build because it's clean, simple, and works everywhere in the app without dragging in state-management packages just for toggling a theme.

Let's jump into it.

<hr style={{ borderColor: 'var(--muted)', paddingBottom: '24px' }} />

### Step 1: Create a new project and install dependencies (optional)

Create a new Flutter project:
```bash
flutter create theme_1
cd theme_1
```

Add shared_preferences if you want to persist the theme choice:
```bash
flutter pub add shared_preferences
```

Now, just remove the boilerplate from <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>main.dart</span>, create your usual <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>app.dart</span> and <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>home.dart</span>, and get a basic MaterialApp running.

### Setp 2: Create the Theme Notifier (this is the core)

We need something to tell the entire app:\
<span style={{ color: 'var(--text-highlight)', fontStyle: 'italic' }}>"Theme mode changed — rebuild yourself."</span>

Flutter already gives us <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>ValueNotifier</span>, so we'll just use that.\
So, let's create a <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>theme_notifier.dart</span> file and write the following code:

```dart
class ThemeNotifier {
  static final ThemeNotifier _instance = ThemeNotifier._internal();
  factory ThemeNotifier() => _instance;

  ThemeNotifier._internal();

  final ValueNotifier<ThemeMode> themeModeNotifier = ValueNotifier<ThemeMode>(
    ThemeMode.system,
  );

  Future<void> loadThemeMode() async {
    // TODO: Load the saved theme mode from local storage
  }

  void toggleTheme() {
    // TODO: Toggle between light and dark theme modes and save the updated preference
  }

  void saveThemeMode(ThemeMode mode) {
    // TODO: Save the selected theme mode to local storage and update the notifier
    // Updating the notifier to rebuild the listeners
  }
}
```

Why a singleton?
Because I want to access this from anywhere in the app without passing BuildContext around like it’s hot potato.

### Step 3: Persisting the theme with SharedPreferences (optional)

If someone switches to dark mode, closes the app, opens it again — the app should *stay* in dark mode.

For this, we can use the <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>shared_preferences</span> package we added earlier.\
Let's create a class called <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>LocalStorage</span> in a file called <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>local_storage.dart</span> to handle saving and retrieving things from local storage:

```dart
class LocalStorage {
  static SharedPreferences? _prefs;
  static SharedPreferences? get prefs => _prefs;

  static Future<void> init() async {
    _prefs = await SharedPreferences.getInstance();
  }

  static Future<void> set(String key, dynamic value) async {
    if (prefs == null) await init();

    if (value is String) {
      await _prefs?.setString(key, value);
    } else if (value is int) {
      await _prefs?.setInt(key, value);
    } else if (value is bool) {
      await _prefs?.setBool(key, value);
    } else if (value is double) {
      await _prefs?.setDouble(key, value);
    } else if (value is List<String>) {
      await _prefs?.setStringList(key, value);
    } else {
      throw Exception("Unsupported value type");
    }
  }

  static T? get<T>(String key, {T? defaultValue}) {
    if (prefs == null) return defaultValue;

    if (T == String) {
      return _prefs?.getString(key) as T? ?? defaultValue;
    } else if (T == int) {
      return _prefs?.getInt(key) as T? ?? defaultValue;
    } else if (T == bool) {
      return _prefs?.getBool(key) as T? ?? defaultValue;
    } else if (T == double) {
      return _prefs?.getDouble(key) as T? ?? defaultValue;
    } else if (T == List<String>) {
      return _prefs?.getStringList(key) as T? ?? defaultValue;
    } else {
      throw Exception("Unsupported value type");
    }
  }

  static Future<void> remove(String key) async {
    if (prefs == null) await init();
    await _prefs?.remove(key);
  }

  static Future<void> clear() async {
    if (prefs == null) await init();
    await _prefs?.clear();
  }
}
```

### Step 4: Complete the theme notifier with persistence

Now let's complete the theme notifier by implementing the <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>loadThemeMode</span>, <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>saveThemeMode</span>, and <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>toggleTheme</span> methods:

```dart
class ThemeNotifier {
  static final ThemeNotifier _instance = ThemeNotifier._internal();
  factory ThemeNotifier() => _instance;

  ThemeNotifier._internal();

  final ValueNotifier<ThemeMode> themeModeNotifier = ValueNotifier<ThemeMode>(
    ThemeMode.system,
  );

  Future<void> loadThemeMode() async {
    final savedTheme = LocalStorage.get<String>(
      "theme_mode",
      defaultValue: "system",
    );

    if (savedTheme == null) {
      themeModeNotifier.value = ThemeMode.system;
      return;
    }

    if (savedTheme == ThemeMode.light.name) {
      themeModeNotifier.value = .light;
    } else if (savedTheme == ThemeMode.dark.name) {
      themeModeNotifier.value = .dark;
    } else {
      themeModeNotifier.value = .system;
    }
  }

  void toggleTheme() {
    if (themeModeNotifier.value == ThemeMode.light) {
      saveThemeMode(.dark);
    } else {
      saveThemeMode(.light);
    }
  }

  void saveThemeMode(ThemeMode mode) {
    themeModeNotifier.value = mode;
    LocalStorage.set("theme_mode", mode.name);
  }
}
```

### Step 5: Setup the material app to listen to theme changes

In your <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>app.dart</span>, wrap your <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>MaterialApp</span> with a <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>ValueListenableBuilder</span> that listens to the <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>themeModeNotifier</span>:

```dart
class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder(
      valueListenable: ThemeNotifier().themeModeNotifier,
      builder: (_, themeMode, _) {
        return MaterialApp(
          debugShowCheckedModeBanner: false,
          themeMode: themeMode,
          theme: ThemeData.light(),
          darkTheme: ThemeData.dark(),
          home: const Home(),
        );
      },
    );
  }
}
```

Finally in your <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>main.dart</span>, initialize the <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>LocalStorage</span> and <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>loadThemeMode</span> before running the app:

```dart
void main(List<String> args) async {
  WidgetsFlutterBinding.ensureInitialized();
  await bootStrap();
  runApp(const App());
}

Future<void> bootStrap() async {
  await LocalStorage.init();
  await ThemeNotifier().loadThemeMode();
}

```

### Step 6: Setup your home.dart

```dart
class Home extends StatelessWidget {
  const Home({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Theme Notifier Example"),
        centerTitle: true,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text("Home Screen"),
            ElevatedButton(
              onPressed: () => ThemeNotifier().toggleTheme(),
              child: const Text("Toggle Theme"),
            ),
          ],
        ),
      ),
    );
  }
}
```

<hr style={{ borderColor: 'var(--muted)', paddingBottom: '24px' }} />

Great! Now we have a working <span style={{ color: 'var(--text-highlight)', fontStyle: 'italic' }}>dark mode</span> and <span style={{ color: 'var(--text-highlight)', fontStyle: 'italic' }}>light mode</span> toggle, with persistence using <span style={{ color: 'var(--text-highlight)', fontStyle: 'italic' }}>local storage</span> and zero external state-management packages. Just simple <span style={{ color: 'var(--destructive)', fontStyle: 'italic' }}>ValueNotifiers</span> doing their job.

Here is the full source code:  
[Theme Notifier Tutorial](https://github.com/ekakshjanweja/theme_notifier_tutorial)

Thanks for reading, hope this helps you keep your theming clean.

